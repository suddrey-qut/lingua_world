#!/usr/bin/env python
import rospy
import json
import pymongo

from geometry_msgs.msg import PoseStamped, Pose
from wire_msgs.msg import WorldState
from sensor_msgs.msg import JointState

from lingua_world.srv import Assert, AssertResponse
from lingua_world.srv import FindObjects, FindObjectsResponse
from lingua_world.srv import GetObjectPose, GetObjectPoseResponse

from std_srvs.srv import Empty

import pddl

def is_open(arg0):
  if arg0.startswith('g'):
    msg = rospy.wait_for_message('/franka_gripper/joint_states', JointState)
    return [arg0] if msg.position[0] > 0.035 and msg.position[1] > 0.035 else []
  return []

class World:
  def __init__(self):
    self.client = pymongo.MongoClient()
    self.db = self.client.lingua

    self.collection = self.db.objects

    self.sub_state = rospy.Subscriber('/world_state', WorldState, self.state_cb)

    self.srv_clear = rospy.Service('/lingua/world/clear', Empty, self.clear_cb)
    
    self.srv_search = rospy.Service('/lingua/world/query', FindObjects, self.query_cb)
    self.srv_assert = rospy.Service('/lingua/world/assert', Assert, self.assert_cb)

    self.srv_pose = rospy.Service('/lingua/world/get_pose', GetObjectPose, self.get_pose_cb)

    self.callbacks = {
      'on': lambda arg1, arg2: ['0'],
      'open': is_open
    }
  
  def state_cb(self, msg):
    for obj in msg.objects:
      entry = {
        'object_id': str(obj.ID),
        'attributes': {}
      }

      for prop in obj.properties:
        if prop.attribute == 'position':
          entry['position'] = {
            'header': {
              'frame_id': msg.header.frame_id,
              'stamp': rospy.Time.now().to_sec()
            },
            'pose': {
              'position': {
                'x': prop.pdf.data[1],
                'y': prop.pdf.data[2],
                'z': prop.pdf.data[3]
              },
              'orientation': {
                'x': 0,
                'y': 0,
                'z': 0,
                'w': 1
              }
            }
          }
        else:
          entry['attributes'][prop.attribute] = prop.pdf.values
      
      self.collection.replace_one({'object_id': entry['object_id']}, entry, upsert=True)
      
  def query_cb(self, req):
    result = pddl.evaluate(self, req.query)
    if pddl.is_iterable(result):
      return FindObjectsResponse(ids=pddl.logical_split(result)[1:])
    return FindObjectsResponse(ids=[result])  
    
  def assert_cb(self, req):
    if pddl.is_query(req.query):
      try:
        pddl.evaluate(self, req.query)
      except pddl.errors.NullStatement:
        return AssertResponse(result=False)
    
    result = self.ask(req.query)
    
    if len(result) > 0:
      return AssertResponse(result=True)
    
    return AssertResponse(result=False)
      
  def get_pose_cb(self, req):
    obj = self.collection.find_one({'object_id': req.object_id})
    
    if not obj:
      rospy.ServiceException('Unknown object with id: {}'.format(req.object_id))

    data = obj['position']
    ps = PoseStamped()
    
    ps.header.frame_id = data['header']['frame_id']
    ps.header.stamp = rospy.Time.from_sec(data['header']['stamp'])

    ps.pose.position.x = data['pose']['position']['x']
    ps.pose.position.y = data['pose']['position']['y']
    ps.pose.position.z = data['pose']['position']['z']
    
    ps.pose.orientation.w = 1

    return GetObjectPoseResponse(pose_stamped=ps)

  def clear_cb(self, req):
    self.collection.delete_many({})

  def ask(self, query):
    args = pddl.logical_split(query)
    
    if args[0] in self.callbacks:
      return self.callbacks[args[0]](*args[1:])
    
    if args[2] == '?':
      result = self.collection.find({'attributes.{}'.format(args[0]): args[1]})
      return [str(item['object_id']) for item in result]
    
    result = self.collection.find({'object_id': args[2], 'attributes.{}'.format(args[0]): args[1]})
    return [str(item['object_id']) for item in result]
    # return ['0']


def main():
  rospy.init_node('world_model')
  world = World()
  rospy.spin()

if __name__ == '__main__':
  main()